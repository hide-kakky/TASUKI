# 14_アルゴリズムとデータ構造基礎 🧮

「コードは動くけど、データが増えたらフリーズした」
それは計算量（オーダー）の意識が不足しているからかもしれません。

## 1. 計算量 (Big O Notation)
処理にかかる時間が、データ量 $N$ に対してどう増えるかを表す指標です。

| 表記 | 名前 | 速さ | 例 |
|---|---|---|---|
| $O(1)$ | 定数時間 | 爆速 | 配列の要素アクセス `arr[5]` |
| $O(\log N)$ | 対数時間 | 速い | 二分探索 (Binary Search) |
| $O(N)$ | 線形時間 | 普通 | forループで全探索 |
| $O(N \log N)$ | | 普通 | 高速なソート (Quick Sort, Merge Sort) |
| $O(N^2)$ | 二乗時間 | 遅い | 二重ループ (`for`の中に`for`) |

**エンジニアの鉄則**:
- データが1万件を超えるなら $O(N^2)$ は避ける。
- $O(N^2)$ の処理を $O(N)$ や $O(N \log N)$ にできないか考える。

## 2. 主要なデータ構造

### List (配列)
- メモリ上に連続して並んでいる。
- **得意**: `arr[i]` でのアクセス ($O(1)$)。
- **苦手**: 途中への挿入・削除 ($O(N)$)。後ろの要素を全部ずらす必要があるから。

### Linked List (連結リスト)
- データが鎖のようにポインタで繋がっている。
- **得意**: 途中への挿入・削除 ($O(1)$)。鎖を繋ぎ変えるだけだから。
- **苦手**: 特定の要素へのアクセス ($O(N)$)。最初から辿る必要があるから。

### Map / HashTable (ハッシュマップ)
- キーと値のペア。最強のデータ構造。
- **得意**: 検索、挿入、削除すべてが平均 $O(1)$。
- **仕組み**: キーをハッシュ関数で計算し、メモリ上の住所に変換する。
- **注意**: ハッシュ衝突（計算結果が被る）と性能が落ちるが、言語レベルで自動対処されていることが多い。

### Tree (木) / Graph (グラフ)
- **Tree**: HTMLのDOMツリー、ファイルシステムなど。階層構造。
- **Graph**: SNSの友達関係、路線図など。網状の構造。

## 3. 実践での使い分け
- 「ID指定でユーザーを取り出したい」 → `List` を `find` するより、最初から `Map<int, User>` で持つべき。
- 「大量のデータを並び替えたい」 → Dartの `sort()` は優秀なアルゴリズム ($O(N \log N)$) を使っているので、自分で書かずに標準関数を使う。

車輪の再発明を避けるためにも、標準ライブラリがどんなアルゴリズムを使っているか知っておくと吉です。

---

## 📚 用語集 (Glossary)

| 用語 | 意味 | 例 |
|------|------|-----|
| **Big O ($O$)** | 計算量を表す記法 | 最悪のケースを想定する |
| **Algorithm (アルゴリズム)** | 問題を解く手順 | ソート, 探索 |
| **Data Structure (データ構造)** | データの持ち方 | List, Map, Tree |
| **List (Array)** | 順番に並んだデータ | `[A, B, C]` |
| **Map (Hash)** | キーと値のペア | `{id: 1, name: A}` |
| **Queue (キュー)** | 先入れ先出し (FIFO) | 行列待ち |
| **Stack (スタック)** | 後入れ先出し (LIFO) | 積み上げた本 |

