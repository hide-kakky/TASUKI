# 03_PostgreSQL内部構造とチューニング 🐘⚙️

Supabaseの中身であるPostgreSQL。
「なぜ遅いのか？」「なぜVACUUMが必要なのか？」を知れば、DBトラブルの9割は解決できます。

## 1. MVCC (Multi-Version Concurrency Control)
ポスグレの最も重要な特徴です。「追記型アーキテクチャ」とも呼ばれます。

- **UPDATEの正体**: データを上書きしているわけではありません。「古い行を無効にして、新しい行を追加」しています。
- **DELETEの正体**: データ消していません。「削除フラグを立てて見えなくしている」だけです。

**なぜ？**
「読み取り中の人」と「書き込み中の人」がお互いを邪魔しないためです。
Aさんがデータを更新中でも、Bさんは「更新前の古いデータ」を安全に読むことができます（ロック待ちが発生しない）。

## 2. VACUUM (バキューム)
追記型ということは、UPDATE/DELETEしまくると「ゴミ（無効な行）」がどんどん溜まり、ディスクを圧迫して遅くなります。
このゴミをお掃除する処理が **VACUUM** です。

- 通常は `Auto Vacuum` が裏で動いてくれています。
- ですが、数百万行を一気に更新/削除した直後は、手動で `VACUUM ANALYZE` を実行したほうが良い場合があります。

## 3. EXPLAIN ANALYZE (実行計画)
「クエリが遅い！」と思ったら、まずこれを頭につけて実行します。
DBが「どうやってデータを取ってくるつもりか」を教えてくれます。

```sql
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';
```

### 見るべきポイント
1. **Seq Scan (シーケンシャルスキャン)**:
   - 全行読み込み。「辞書の1ページ目から全部めくって探す」状態。遅い。
   - インデックスが必要です。
2. **Index Scan (インデックススキャン)**:
   - インデックスを使って検索。「索引を見てページを開く」状態。速い。
3. **Execution Time**: 実際にかかった時間。

## 4. N+1問題
アプリ開発で最も頻発するパフォーマンス問題です。

```dart
// 1. ユーザーを100人取得 (SELECT * FROM users)
final users = await getUsers();

for (var user in users) {
  // 2. ユーザーごとにプロフィールを取得 (SELECT * FROM profiles WHERE user_id = ?)
  // → 100回クエリが飛ぶ！ 合計101回！
  final profile = await getProfile(user.id);
}
```
**解決策:**
SQLの `JOIN` を使うか、Supabaseの `.select('*, profiles(*)')` を使って、**1回のクエリ** でまとめて取得しましょう。
「ループの中でSQLを叩くな」は鉄則です。

---

## 📚 用語集 (Glossary)

| 用語 | 意味 | イメージ |
|------|------|-----|
| **MVCC** | 多版型同時実行制御 | 上書きせずに履歴を残す仕組み |
| **VACUUM** | お掃除 | 不要になった「古い版」を消す |
| **EXPLAIN** | 実行計画 | 「どうやって探すつもり？」と聞く |
| **Seq Scan** | 全件走査 | 力技。遅い。 |
| **Index Scan** | 索引走査 | スマート。速い。 |
| **N+1問題** | 効率の悪いクエリの代表格 | 1回で済む買い物を100回に分けるようなもの |
| **WAL (Write Ahead Log)** | 操作ログ | 変更内容はまずここに書かれる |

## 🛠️ コマンド集 (SQL Performance)

| コマンド | 説明 |
|---|---|
| `EXPLAIN ANALYZE <query>` | クエリの実際の実行時間を計測・表示する |
| `VACUUM ANALYZE <table>` | ガーベージコレクションを実行し、統計情報を更新する |
| `reindex table <table>` | 壊れたり肥大化したインデックスを作り直す |
