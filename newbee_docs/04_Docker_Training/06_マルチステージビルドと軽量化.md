# Docker上級編: イメージの軽量化とマルチステージビルド 🏎️

「動けばいい」から「実運用に耐える」コンテナへ。
イメージサイズを小さくし、ビルド時間を短縮し、セキュリティを高めるテクニックです。

## 1. なぜサイズが重要なのか？
- **デプロイ速度**: 1GBのイメージより100MBのイメージの方が、サーバーへの転送も起動も圧倒的に速い。
- **コスト**: クラウドのストレージコストや転送量課金を削減できる。
- **セキュリティ**: 不要なツール（curlやvimなど）が入っていると、攻撃者に利用されるリスクが増える。

## 2. マルチステージビルド (Multi-stage Build)
ビルドに必要な環境（GoやNode.jsの全ツール）と、実行に必要な環境（コンパイル済みのバイナリだけ）を分ける技術です。

### 悪い例 (Single Stage)
```dockerfile
FROM golang:1.21
WORKDIR /app
COPY . .
RUN go build -o main .
CMD ["./main"]
```
これだと、Goのコンパイラやソースコードそのものもイメージに含まれてしまい、サイズが800MBを超えます。

### 良い例 (Multi-stage)
```dockerfile
# --- Build Stage ---
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
# バイナリを作成
RUN go build -o main .

# --- Run Stage ---
# 実行には超軽量なAlpine Linuxを使う
FROM alpine:latest
WORKDIR /root/
# Builderステージから成果物だけをコピー
COPY --from=builder /app/main .
CMD ["./main"]
```
これなら、コンパイラは捨ててバイナリだけを持ってくるので、サイズは**20MB程度**（1/40！）になります。

## 3. レイヤーの最小化
Dockerは `RUN`, `COPY`, `ADD` などの命令ごとに「レイヤー（層）」を作ります。

```dockerfile
# 悪い例: 3つのレイヤーができる
RUN apt-get update
RUN apt-get install -y python3
RUN rm -rf /var/lib/apt/lists/*
```

```dockerfile
# 良い例: まとめて1つのレイヤーにする
RUN apt-get update && apt-get install -y python3 \
    && rm -rf /var/lib/apt/lists/*
```
キャッシュなどの不要ファイルは、**同じRUN命令の中で**削除しないと、前のレイヤーに残ってしまいサイズが減りません。

## 4. distroless (ディストロレス) イメージ
究極の軽量化として、シェル（bash）さえ入っていない Google製の `distroless` イメージを使う手法もあります。
本番環境でのデバッグは難しくなりますが、セキュリティは最強です。

```dockerfile
FROM gcr.io/distroless/static-debian11
COPY --from=builder /app/main /
CMD ["/main"]
```

## 今日の格言
**「コンテナには、アプリケーションと、それを動かすための最小限の依存関係だけを入れよ」**

---

## 📚 用語集 (Glossary)

| 用語 | 意味 | 補足 |
|------|------|-----|
| **Multi-stage Build** | 多段階ビルド | 作る場所(Build)と動かす場所(Run)を分ける技術 |
| **Layer (レイヤー)** | 層 | Dockerイメージは命令ごとの層の積み重ね |
| **Alpine Linux** | 超軽量Linux | わずか5MB程度。頻繁に使われる。 |
| **Distroless** | シェルすらないLinux | Google製。セキュリティ最強だがデバッグ困難。 |
| **Cache (キャッシュ)** | 一度やったことの記憶 | Dockerビルドの高速化の肝 |

